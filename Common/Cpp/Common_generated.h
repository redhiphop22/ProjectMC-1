// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_COMMON_H_
#define FLATBUFFERS_GENERATED_COMMON_COMMON_H_

#include "flatbuffers/flatbuffers.h"

#include "Result_generated.h"

namespace common {

struct CHARACTER_INFO;
struct CHARACTER_INFOBuilder;

struct CHARACTER_FACE;
struct CHARACTER_FACEBuilder;

struct CHARACTER_EQUIPMENT;
struct CHARACTER_EQUIPMENTBuilder;

enum ACCOUNT_AUTHORITY : uint8_t {
  ACCOUNT_AUTHORITY_GUEST = 0,
  ACCOUNT_AUTHORITY_STUDENT = 1,
  ACCOUNT_AUTHORITY_PROFESSOR = 2,
  ACCOUNT_AUTHORITY_ADMINISTRATOR = 99,
  ACCOUNT_AUTHORITY_MIN = ACCOUNT_AUTHORITY_GUEST,
  ACCOUNT_AUTHORITY_MAX = ACCOUNT_AUTHORITY_ADMINISTRATOR
};

inline const ACCOUNT_AUTHORITY (&EnumValuesACCOUNT_AUTHORITY())[4] {
  static const ACCOUNT_AUTHORITY values[] = {
    ACCOUNT_AUTHORITY_GUEST,
    ACCOUNT_AUTHORITY_STUDENT,
    ACCOUNT_AUTHORITY_PROFESSOR,
    ACCOUNT_AUTHORITY_ADMINISTRATOR
  };
  return values;
}

inline const char *EnumNameACCOUNT_AUTHORITY(ACCOUNT_AUTHORITY e) {
  switch (e) {
    case ACCOUNT_AUTHORITY_GUEST: return "GUEST";
    case ACCOUNT_AUTHORITY_STUDENT: return "STUDENT";
    case ACCOUNT_AUTHORITY_PROFESSOR: return "PROFESSOR";
    case ACCOUNT_AUTHORITY_ADMINISTRATOR: return "ADMINISTRATOR";
    default: return "";
  }
}

enum ACCOUNT_BLOCK_TYPE : uint8_t {
  ACCOUNT_BLOCK_TYPE_NONE = 0,
  ACCOUNT_BLOCK_TYPE_MIN = ACCOUNT_BLOCK_TYPE_NONE,
  ACCOUNT_BLOCK_TYPE_MAX = ACCOUNT_BLOCK_TYPE_NONE
};

inline const ACCOUNT_BLOCK_TYPE (&EnumValuesACCOUNT_BLOCK_TYPE())[1] {
  static const ACCOUNT_BLOCK_TYPE values[] = {
    ACCOUNT_BLOCK_TYPE_NONE
  };
  return values;
}

inline const char * const *EnumNamesACCOUNT_BLOCK_TYPE() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameACCOUNT_BLOCK_TYPE(ACCOUNT_BLOCK_TYPE e) {
  if (flatbuffers::IsOutRange(e, ACCOUNT_BLOCK_TYPE_NONE, ACCOUNT_BLOCK_TYPE_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesACCOUNT_BLOCK_TYPE()[index];
}

enum CHARACTER_TYPE : uint8_t {
  CHARACTER_TYPE_NONE = 0,
  CHARACTER_TYPE_MAN = 1,
  CHARACTER_TYPE_WOMAN = 2,
  CHARACTER_TYPE_MIN = CHARACTER_TYPE_NONE,
  CHARACTER_TYPE_MAX = CHARACTER_TYPE_WOMAN
};

inline const CHARACTER_TYPE (&EnumValuesCHARACTER_TYPE())[3] {
  static const CHARACTER_TYPE values[] = {
    CHARACTER_TYPE_NONE,
    CHARACTER_TYPE_MAN,
    CHARACTER_TYPE_WOMAN
  };
  return values;
}

inline const char * const *EnumNamesCHARACTER_TYPE() {
  static const char * const names[4] = {
    "NONE",
    "MAN",
    "WOMAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCHARACTER_TYPE(CHARACTER_TYPE e) {
  if (flatbuffers::IsOutRange(e, CHARACTER_TYPE_NONE, CHARACTER_TYPE_WOMAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCHARACTER_TYPE()[index];
}

enum CHARACTER_EQUIPMENT_TYPE : uint8_t {
  CHARACTER_EQUIPMENT_TYPE_TOP = 0,
  CHARACTER_EQUIPMENT_TYPE_BOTTOM = 1,
  CHARACTER_EQUIPMENT_TYPE_ONEPIECE = 2,
  CHARACTER_EQUIPMENT_TYPE_SHOES = 3,
  CHARACTER_EQUIPMENT_TYPE_EYELASH = 4,
  CHARACTER_EQUIPMENT_TYPE_EYESHADOW = 5,
  CHARACTER_EQUIPMENT_TYPE_FACIAL_HAIR = 6,
  CHARACTER_EQUIPMENT_TYPE_PIERCING = 7,
  CHARACTER_EQUIPMENT_TYPE_TATTOO = 8,
  CHARACTER_EQUIPMENT_TYPE_HAT = 9,
  CHARACTER_EQUIPMENT_TYPE_GLASSES = 10,
  CHARACTER_EQUIPMENT_TYPE_EARRING = 11,
  CHARACTER_EQUIPMENT_TYPE_NECKLACE = 12,
  CHARACTER_EQUIPMENT_TYPE_WATCH = 13,
  CHARACTER_EQUIPMENT_TYPE_BAG = 14,
  CHARACTER_EQUIPMENT_TYPE_SMARTPHONE = 15,
  CHARACTER_EQUIPMENT_TYPE_MIN = CHARACTER_EQUIPMENT_TYPE_TOP,
  CHARACTER_EQUIPMENT_TYPE_MAX = CHARACTER_EQUIPMENT_TYPE_SMARTPHONE
};

inline const CHARACTER_EQUIPMENT_TYPE (&EnumValuesCHARACTER_EQUIPMENT_TYPE())[16] {
  static const CHARACTER_EQUIPMENT_TYPE values[] = {
    CHARACTER_EQUIPMENT_TYPE_TOP,
    CHARACTER_EQUIPMENT_TYPE_BOTTOM,
    CHARACTER_EQUIPMENT_TYPE_ONEPIECE,
    CHARACTER_EQUIPMENT_TYPE_SHOES,
    CHARACTER_EQUIPMENT_TYPE_EYELASH,
    CHARACTER_EQUIPMENT_TYPE_EYESHADOW,
    CHARACTER_EQUIPMENT_TYPE_FACIAL_HAIR,
    CHARACTER_EQUIPMENT_TYPE_PIERCING,
    CHARACTER_EQUIPMENT_TYPE_TATTOO,
    CHARACTER_EQUIPMENT_TYPE_HAT,
    CHARACTER_EQUIPMENT_TYPE_GLASSES,
    CHARACTER_EQUIPMENT_TYPE_EARRING,
    CHARACTER_EQUIPMENT_TYPE_NECKLACE,
    CHARACTER_EQUIPMENT_TYPE_WATCH,
    CHARACTER_EQUIPMENT_TYPE_BAG,
    CHARACTER_EQUIPMENT_TYPE_SMARTPHONE
  };
  return values;
}

inline const char * const *EnumNamesCHARACTER_EQUIPMENT_TYPE() {
  static const char * const names[17] = {
    "TOP",
    "BOTTOM",
    "ONEPIECE",
    "SHOES",
    "EYELASH",
    "EYESHADOW",
    "FACIAL_HAIR",
    "PIERCING",
    "TATTOO",
    "HAT",
    "GLASSES",
    "EARRING",
    "NECKLACE",
    "WATCH",
    "BAG",
    "SMARTPHONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCHARACTER_EQUIPMENT_TYPE(CHARACTER_EQUIPMENT_TYPE e) {
  if (flatbuffers::IsOutRange(e, CHARACTER_EQUIPMENT_TYPE_TOP, CHARACTER_EQUIPMENT_TYPE_SMARTPHONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCHARACTER_EQUIPMENT_TYPE()[index];
}

struct CHARACTER_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHARACTER_INFOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HAIR_IDX = 6,
    VT_HAIR_COLOR = 8,
    VT_FACE_IDX = 10,
    VT_FACE_COLOR = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint16_t hair_idx() const {
    return GetField<uint16_t>(VT_HAIR_IDX, 0);
  }
  uint8_t hair_color() const {
    return GetField<uint8_t>(VT_HAIR_COLOR, 0);
  }
  uint16_t face_idx() const {
    return GetField<uint16_t>(VT_FACE_IDX, 0);
  }
  uint8_t face_color() const {
    return GetField<uint8_t>(VT_FACE_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_HAIR_IDX) &&
           VerifyField<uint8_t>(verifier, VT_HAIR_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_FACE_IDX) &&
           VerifyField<uint8_t>(verifier, VT_FACE_COLOR) &&
           verifier.EndTable();
  }
};

struct CHARACTER_INFOBuilder {
  typedef CHARACTER_INFO Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CHARACTER_INFO::VT_NAME, name);
  }
  void add_hair_idx(uint16_t hair_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_INFO::VT_HAIR_IDX, hair_idx, 0);
  }
  void add_hair_color(uint8_t hair_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_INFO::VT_HAIR_COLOR, hair_color, 0);
  }
  void add_face_idx(uint16_t face_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_INFO::VT_FACE_IDX, face_idx, 0);
  }
  void add_face_color(uint8_t face_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_INFO::VT_FACE_COLOR, face_color, 0);
  }
  explicit CHARACTER_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CHARACTER_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHARACTER_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHARACTER_INFO> CreateCHARACTER_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint16_t hair_idx = 0,
    uint8_t hair_color = 0,
    uint16_t face_idx = 0,
    uint8_t face_color = 0) {
  CHARACTER_INFOBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_face_idx(face_idx);
  builder_.add_hair_idx(hair_idx);
  builder_.add_face_color(face_color);
  builder_.add_hair_color(hair_color);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHARACTER_INFO> CreateCHARACTER_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t hair_idx = 0,
    uint8_t hair_color = 0,
    uint16_t face_idx = 0,
    uint8_t face_color = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return common::CreateCHARACTER_INFO(
      _fbb,
      name__,
      hair_idx,
      hair_color,
      face_idx,
      face_color);
}

struct CHARACTER_FACE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHARACTER_FACEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAIR_IDX = 4,
    VT_HAIR_COLOR = 6,
    VT_FACE_IDX = 8,
    VT_FACE_COLOR = 10,
    VT_EYE_IDX = 12,
    VT_EYE_COLOR = 14,
    VT_EYEBROW_IDX = 16,
    VT_EYEBROW_COLOR = 18,
    VT_NOSE_IDX = 20,
    VT_NOSE_COLOR = 22,
    VT_MOUTH_IDX = 24,
    VT_MOUTH_COLOR = 26
  };
  uint16_t hair_idx() const {
    return GetField<uint16_t>(VT_HAIR_IDX, 0);
  }
  uint8_t hair_color() const {
    return GetField<uint8_t>(VT_HAIR_COLOR, 0);
  }
  uint16_t face_idx() const {
    return GetField<uint16_t>(VT_FACE_IDX, 0);
  }
  uint8_t face_color() const {
    return GetField<uint8_t>(VT_FACE_COLOR, 0);
  }
  uint16_t eye_idx() const {
    return GetField<uint16_t>(VT_EYE_IDX, 0);
  }
  uint8_t eye_color() const {
    return GetField<uint8_t>(VT_EYE_COLOR, 0);
  }
  uint16_t eyebrow_idx() const {
    return GetField<uint16_t>(VT_EYEBROW_IDX, 0);
  }
  uint8_t eyebrow_color() const {
    return GetField<uint8_t>(VT_EYEBROW_COLOR, 0);
  }
  uint16_t nose_idx() const {
    return GetField<uint16_t>(VT_NOSE_IDX, 0);
  }
  uint8_t nose_color() const {
    return GetField<uint8_t>(VT_NOSE_COLOR, 0);
  }
  uint16_t mouth_idx() const {
    return GetField<uint16_t>(VT_MOUTH_IDX, 0);
  }
  uint8_t mouth_color() const {
    return GetField<uint8_t>(VT_MOUTH_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HAIR_IDX) &&
           VerifyField<uint8_t>(verifier, VT_HAIR_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_FACE_IDX) &&
           VerifyField<uint8_t>(verifier, VT_FACE_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_EYE_IDX) &&
           VerifyField<uint8_t>(verifier, VT_EYE_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_EYEBROW_IDX) &&
           VerifyField<uint8_t>(verifier, VT_EYEBROW_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_NOSE_IDX) &&
           VerifyField<uint8_t>(verifier, VT_NOSE_COLOR) &&
           VerifyField<uint16_t>(verifier, VT_MOUTH_IDX) &&
           VerifyField<uint8_t>(verifier, VT_MOUTH_COLOR) &&
           verifier.EndTable();
  }
};

struct CHARACTER_FACEBuilder {
  typedef CHARACTER_FACE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hair_idx(uint16_t hair_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_HAIR_IDX, hair_idx, 0);
  }
  void add_hair_color(uint8_t hair_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_HAIR_COLOR, hair_color, 0);
  }
  void add_face_idx(uint16_t face_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_FACE_IDX, face_idx, 0);
  }
  void add_face_color(uint8_t face_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_FACE_COLOR, face_color, 0);
  }
  void add_eye_idx(uint16_t eye_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_EYE_IDX, eye_idx, 0);
  }
  void add_eye_color(uint8_t eye_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_EYE_COLOR, eye_color, 0);
  }
  void add_eyebrow_idx(uint16_t eyebrow_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_EYEBROW_IDX, eyebrow_idx, 0);
  }
  void add_eyebrow_color(uint8_t eyebrow_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_EYEBROW_COLOR, eyebrow_color, 0);
  }
  void add_nose_idx(uint16_t nose_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_NOSE_IDX, nose_idx, 0);
  }
  void add_nose_color(uint8_t nose_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_NOSE_COLOR, nose_color, 0);
  }
  void add_mouth_idx(uint16_t mouth_idx) {
    fbb_.AddElement<uint16_t>(CHARACTER_FACE::VT_MOUTH_IDX, mouth_idx, 0);
  }
  void add_mouth_color(uint8_t mouth_color) {
    fbb_.AddElement<uint8_t>(CHARACTER_FACE::VT_MOUTH_COLOR, mouth_color, 0);
  }
  explicit CHARACTER_FACEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CHARACTER_FACE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHARACTER_FACE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHARACTER_FACE> CreateCHARACTER_FACE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t hair_idx = 0,
    uint8_t hair_color = 0,
    uint16_t face_idx = 0,
    uint8_t face_color = 0,
    uint16_t eye_idx = 0,
    uint8_t eye_color = 0,
    uint16_t eyebrow_idx = 0,
    uint8_t eyebrow_color = 0,
    uint16_t nose_idx = 0,
    uint8_t nose_color = 0,
    uint16_t mouth_idx = 0,
    uint8_t mouth_color = 0) {
  CHARACTER_FACEBuilder builder_(_fbb);
  builder_.add_mouth_idx(mouth_idx);
  builder_.add_nose_idx(nose_idx);
  builder_.add_eyebrow_idx(eyebrow_idx);
  builder_.add_eye_idx(eye_idx);
  builder_.add_face_idx(face_idx);
  builder_.add_hair_idx(hair_idx);
  builder_.add_mouth_color(mouth_color);
  builder_.add_nose_color(nose_color);
  builder_.add_eyebrow_color(eyebrow_color);
  builder_.add_eye_color(eye_color);
  builder_.add_face_color(face_color);
  builder_.add_hair_color(hair_color);
  return builder_.Finish();
}

struct CHARACTER_EQUIPMENT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHARACTER_EQUIPMENTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ID = 6
  };
  common::CHARACTER_EQUIPMENT_TYPE type() const {
    return static_cast<common::CHARACTER_EQUIPMENT_TYPE>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CHARACTER_EQUIPMENTBuilder {
  typedef CHARACTER_EQUIPMENT Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(common::CHARACTER_EQUIPMENT_TYPE type) {
    fbb_.AddElement<uint8_t>(CHARACTER_EQUIPMENT::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(CHARACTER_EQUIPMENT::VT_ID, id, 0);
  }
  explicit CHARACTER_EQUIPMENTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CHARACTER_EQUIPMENT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHARACTER_EQUIPMENT>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHARACTER_EQUIPMENT> CreateCHARACTER_EQUIPMENT(
    flatbuffers::FlatBufferBuilder &_fbb,
    common::CHARACTER_EQUIPMENT_TYPE type = common::CHARACTER_EQUIPMENT_TYPE_TOP,
    uint32_t id = 0) {
  CHARACTER_EQUIPMENTBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace common

#endif  // FLATBUFFERS_GENERATED_COMMON_COMMON_H_
